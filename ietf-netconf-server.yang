module ietf-netconf-server {

  namespace "urn:ietf:params:xml:ns:yang:ietf-netconf-server";
  prefix "ncserver";

  import ietf-inet-types {
    prefix inet;                // RFC 6991
  }
  import ietf-x509-cert-to-name {
    prefix x509c2n;             // draft-ietf-netmod-snmp-cfg
  }
 
  organization
   "IETF NETCONF (Network Configuration) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netconf/>
    WG List:  <mailto:netconf@ietf.org>

    WG Chair: Mehmet Ersue
              <mailto:mehmet.ersue@nsn.com>

    WG Chair: Bert Wijnen
              <mailto:bertietf@bwijnen.net>

    Editor:   Kent Watsen
              <mailto:kwatsen@juniper.net>";


  description
   "This module contains a collection of YANG definitions for
    configuring NETCONF servers.

    Copyright (c) 2014 IETF Trust and the persons identified as
    authors of the code. All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD
    License set forth in Section 4.c of the IETF Trust's
    Legal Provisions Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC XXXX; see
    the RFC itself for full legal notices.";
  // RFC Ed.: replace XXXX with actual RFC number and
  // remove this note

  // RFC Ed.: please update the date to the date of publication

  revision "1111-11-11" {  // YYYY-MM-DD
    description
     "Initial version";
    reference
     "RFC XXXX: NETCONF Server Configuration Model";
  }


  // Features

  feature ssh-listen {
    description
     "The ssh-listen feature indicates that the NETCONF server can
      open a port to listen for incoming client connections.";
  }

  feature ssh-call-home {
    description
     "The ssh-call-home feature indicates that the NETCONF server can
      connect to a client.";
    reference
     "RFC XXXX: Reverse Secure Shell (Reverse SSH)";
  }

  feature tls-listen {
    description
     "The tls-listen feature indicates that the NETCONF server can
      open a port to listen for incoming client connections.";
  }

  feature tls-call-home {
    description
     "The tls-call-home feature indicates that the NETCONF server can
      connect to a client.";
  }



  // top-level container  (groupings below)
  container netconf-server {
    description
      "Top-level container for NETCONF server configuration.";

    uses listen-container;
    uses call-home-container;
    uses ssh-container;
    uses tls-container;
  }



  grouping listen-container {
    description
      "";
    container listen {
      description
        "Configures listen behavior";
      //if-feature "(ssh-listen or tls-listen)";
      list endpoint {
        key name;
        description
          "List of endpoints to listen for connections on.";
        leaf name {
          type string;
          description
            "An arbitrary name for the listen endpoint.";
        }
        choice transport {
          mandatory true;
          description
            "Selects between SSH and TLS transports.";
          case ssh {
            if-feature ssh-listen;
            container ssh {
              description
                "SSH-specific listening configuration for inbound
                 connections.";
              uses address-and-port-grouping {
                refine port {
                  default 830;
                }
              }
              uses host-keys-container;
            }
          }
          case tls {
            if-feature tls-listen;
            container tls {
              description
                "TLS-specific listening configuration for inbound
                 connections.";
              uses address-and-port-grouping {
                refine port {
                  default 6513;
                }
              }
              uses certificates-container;
            }
          }
        }
      }
    }
  }

  grouping call-home-container {
    description
      "";
    container call-home {
      //if-feature "(ssh-call-home or tls-call-home)";
      description
        "Configures call-home behavior";
      list application {
        key name;
        description
          "List of applications to call-home to.";
        leaf name {
          type string;
          description
            "An arbitrary name for the remote application.";
        }
        choice transport {
          mandatory true;
          description
            "Selects between SSH and TLS transports.";
          case ssh {
            if-feature ssh-call-home;
            container ssh {
              description
                "Specifies SSH-specific call-home transport
                 configuration.";
              uses endpoints-container {
                refine endpoints/endpoint/port {
                  default 8888;  // pending IANA assignment
                }
              }
              uses host-keys-container;
            }
          }
          case tls {
            if-feature tls-call-home;
            container tls {
              description
                "Specifies TLS-specific call-home transport
                 configuration.";
              uses endpoints-container {
                refine endpoints/endpoint/port {
                  default 9999;  // pending IANA assignment
                }
              }
              uses certificates-container;
            }
          }
        }
        container connection-type {
          description
           "Indicates the NETCONF client's preference for how the
            device's connection is maintained.";
          choice connection-type {
            default persistent-connection;
            description
              "Selects between persistent and periodic connections.";
            case persistent-connection {
              container persistent {
                description
                 "Maintain a persistent connection to the
                  NETCONF client. If the connection goes down,
                  immediately start trying to reconnect to it,
                  using the reconnection strategy.
    
                  This connection type minimizes any NETCONF 
                  client to NETCONF server data-transfer delay,
                  albeit at the expense of holding resources
                  longer.";
                container keep-alives {
                  description
                    "Configures the keep-alive policy, to proactively
                     test the aliveness of the NETCONF client, in 
                     order to know when a new call home connection 
                     should be established.  Keepalive implementation
                     is described in RFC XXXX, section 4.";
                  reference
                    "RFC XXXX: NETCONF Server Configuration Model 
                     Section 4";
                  leaf interval-secs {
                    type uint8;
                    units seconds;
                    default 15;
                    description
                     "Sets a timeout interval in seconds after which
                      if no data has been received from the NETCONF 
                      client, a message will be sent to request a 
                      response from the NETCONF client.  A value of
                      '0' indicates that no keep-alive messages 
                      should be sent.";
                  }
                  leaf count-max {
                    type uint8;
                    default 3;
                    description
                     "Sets the number of keep-alive messages that 
                      may be sent without receiving any data from 
                      the NETCONF client before assuming the NETCONF 
                      client is no longer alive.  If this threshold 
                      is reached, the transport-level connection
                      will be disconnected, which will trigger the 
                      reconnection strategy).  The interval timer is
                      reset after each transmission, thus an 
                      unresponsive NETCONF client will be dropped
                      after ~count-max * interval-secs seconds.";
                  }
                }
              }
            }
            case periodic-connection {
              container periodic {
                description
                 "Periodically connect to NETCONF client, using the
                  reconnection strategy, so the NETCONF client can 
                  deliver pending messages to the NETCONF server.
    
                  For messages the NETCONF server wants to send to
                  to the NETCONF client, the NETCONF server should
                  proactively connect to the NETCONF client, if
                  not already, to send the messages immediately.";
                leaf timeout-mins {
                  type uint8;
                  units minutes;
                  default 5;
                  description
                   "The maximum amount of unconnected time the
                    device will wait until establishing a
                    connection to the NETCONF client again. The
                    device MAY establish a connection before this
                    time if it has data it needs to send to the
                    NETCONF client. Note: this value differs from
                    the reconnection strategy's interval-secs
                    value.";
                }
                leaf linger-secs {
                  type uint8;
                  units seconds;
                  default 30;
                  description
                   "The amount of time the device should wait after
                    last receiving data from or sending data to the
                    NETCONF client's endpoint before closing its 
                    connection to it.  This is an optimization to 
                    prevent unnecessary connections.";
                }
              }
            }
          }
        }
        container reconnect-strategy {
          description
           "The reconnection strategy guides how a device reconnects
            to an application, after losing a connection to it, 
            even if due to a reboot.  The device starts with the 
            specified endpoint, tries to connect to it count-max 
            times, waiting interval-secs between each connection
            attempt, before trying the next endpoint in the list 
            (round robin).";
          leaf start-with {
            type enumeration {
              enum first-listed {
                description
                  "Indicates that reconnections should start with
                   the first endpoint listed.";
              }
              enum last-connected { 
                description
                  "Indicates that reconnections should start with
                   the endpoint last connected to.  NETCONF servers
                   SHOULD support this flag across reboots.";
              }
            }
            default first-listed;
            description
             "Specifies which of the application's endpoints the
              device should start with when trying to connect to
              the application.  If no previous connection has
              ever been established, last-connected defaults to
              the first endpoint listed.";
          }
          leaf interval-secs {
            type uint8;
            units seconds;
            default 5;
            description
             "Specifies the time delay between connection attempts
              to the same endpoint.  Note: this value differs from
              the periodic-connection's timeout-mins value.";
          }
          leaf count-max {
            type uint8;
            default 3;
            description
             "Specifies the number times the device tries to
              connect to a specific endpoint before moving on to
              the next endpoint in the list (round robin).";
          }
        }
      }
    }
  }


  grouping ssh-container {
    description
      "";
    container ssh {
      description
        "Configures SSH properties not specific to the listen 
         or call-home use-cases";
      //if-feature "(ssh-listen or ssh-call-home)";
      container host-keys {
        description
          "Parent container for a list of host keys";
        list host-key {
          key name;
          config false;
          description
            "A read-only list of host-keys supported by server";
          leaf name {
            type string;
            description
              "Common name for the host-key";
          }
          leaf format-identifier {
            type string;
            mandatory true;
            description
              "ssh-dss, ssh-rsa, x509v3-rsa2048-sha256, etc.";
            reference
              "RFC 4253: SSH Transport Layer Protocol, section 6.6
               RFC 6187: X.509v3 Certificates for SSH, section 3";
          }
          leaf data {
            type binary;
            mandatory true;
            description
              "Key-specific binary encoding.";
            reference
              "RFC 4253: SSH Transport Layer Protocol, section 6.6";
          }
          leaf fingerprint {
            type string;
            mandatory true;
            description
              "c1:b1:30:29:d7:b8:de:6c:97:77:10:d7:46:41:63:87";
            reference
              "RFC 4716: The Secure Shell (SSH) Public Key File 
                         Format, section 4";
          }
        }     
      }
    }
  }


  grouping tls-container {
    description
      "";
    container tls {
      description
        "Configures TLS properties not specific to the listen 
         or call-home use-cases";
      //if-feature "(tls-listen or tls-call-home)";
      container certificates {
        description
          "Parent container for a list of certificates";
        list certificate {
          key name;
          config false;
          description
            "A list of certificates";
          leaf name {
            type string;
            description
              "the certificate's common name";
          }
          leaf data {
            type binary;
            mandatory true;
            description
              "The binary certificate structure, as specified 
               by RFC 5246, Section 7.4.2, i.e.,: opaque 
               ASN.1Cert<1..2^24-1>;";
          }
        }
      }
      container client-auth {
        description
          "Container for TLS client authentication configuration.";
        container trusted-ca-certs {
          description
            "A list of Certificate Authority (CA) certificates that
             a NETCONF server can use to authenticate the  NETCONF 
             client certificate.  A client's certificate is 
             authenticated if its Issuer matches one of the 
             configured trusted CA certificates.";
          leaf-list trusted-ca-cert {
            type binary;
            ordered-by system;
            description
              "The binary certificate structure, as
               specified by RFC 5246, Section 7.4.6, i.e.,:
    
                 opaque ASN.1Cert<1..2^24>;
    
              ";
            reference
              "RFC 5246: The Transport Layer Security (TLS)
                         Protocol Version 1.2";
          }
        }
        container trusted-client-certs {
          description
            "A list of client certificates that a NETCONF server can
             use to authenticate a NETCONF client's certificate.  A
             client's certificate is authenticated if it is an exact
             match to a configured trusted client certificates.";
          leaf-list trusted-client-cert {
            type binary;
            ordered-by system;
            description
              "The binary certificate structure, as
               specified by RFC 5246, Section 7.4.6, i.e.,:
    
                 opaque ASN.1Cert<1..2^24>;
    
              ";
            reference
              "RFC 5246: The Transport Layer Security (TLS)
                         Protocol Version 1.2";
          }
        }
        container cert-maps {
          uses x509c2n:cert-to-name;
          description
           "The cert-maps container is used by a NETCONF server to
            map the NETCONF client's presented X.509 certificate to
            a NETCONF username.
    
            If no matching and valid cert-to-name list entry can be
            found, then the NETCONF server MUST close the connection,
            and MUST NOT accept NETCONF messages over it.";
        }
      }
    }
  }


  grouping host-keys-container {
    description
      "";
    container host-keys {
      description
        "Parent container for the list of host-keys.";
      leaf-list host-key {
        type string;
        min-elements 1;
        ordered-by user;
        description
          "User-ordered list of host-keys the SSH server 
           considers when composing the list of  server
           host key algorithms it will send to the client.
           The value of the string is the name of a 
           host-key configured on the system, as returned
           by /netconf-server/ssh/host-keys/host-key/name.";
        reference
          "RFC 4253: The SSH Transport Layer Protocol, Section 7";
      }
    }
  }

  grouping certificates-container {
    description
      "";
    container certificates {
      description
        "Parent container for the list of certificates.";
      leaf-list certificate {
        type string;
        min-elements 1;
        description
          "Unordered list of certificates the TLS server can
           pick from when sending its Server Certificate
           message.  The value of the string is the name of a
           certificate configured on the system, as returned by
           /netconf-server/tls/certificates/certificate/name";
        reference
          "RFC 5246: The TLS Protocol, Section 7.4.2";
      }
    }
  }

  grouping address-and-port-grouping {
    description
      "a common grouping";
    leaf address {
      type inet:ip-address;
      mandatory true;
      description
       "The IP address of the interface to listen on.";
    }
    leaf port {
      type inet:port-number;
      description
       "The local port number on this interface the
        NETCONF server listens on.";
    }
  }


  grouping endpoints-container {
    description
      "Grouping for transport-specific configuration for
       call-home connections.";
    container endpoints {
      description
        "Container for the list of endpoints.";
      list endpoint {
        key name;
        min-elements 1;
        ordered-by user;
        description
          "User-ordered list of endpoints for this application.
           Defining more than one enables high-availability.";
        leaf name {
          type string;
          description
            "An arbitrary name for the endpoint to connect to.";
        }
        leaf address {
          type inet:host;
          mandatory true;
          description
           "The hostname or IP address or hostname of the 
            endpoint.  If a hostname is provided and DNS 
            resolves to more than one IP address, the device
            SHOULD try all of the ones it can based on how 
            its networking stack is configured (e.g. v4, v6, 
            dual-stack).";
        }
        leaf port {
          type inet:port-number;
          description
           "The IP port for this endpoint. The device will use
            the IANA-assigned well-known port if not specified.";
        }
      }
    }
  }


}

