<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc4251 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4251.xml">
<!ENTITY rfc4252 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4252.xml">
<!ENTITY rfc4253 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4253.xml">
<!ENTITY rfc5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY rfc6020 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6020.xml">
<!ENTITY rfc6187 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6187.xml">
<!ENTITY rfc6241 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6241.xml">
<!ENTITY rfc6242 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6242.xml">
<!ENTITY rfc6335 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6335.xml">
<!ENTITY rfc6520 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6520.xml">
<!ENTITY rfc6536 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6536.xml">
<!ENTITY rfc6991 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6991.xml">
]>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!--<?rfc strict="no"?> -->

<rfc category="std"
     ipr="trust200902"
     docName="draft-ietf-netconf-server-model-latest" >
    <front>
        <title abbrev="NETCONF Server Configuration Model">NETCONF Server Configuration Model</title>
        <author initials="K.W." surname="Watsen" fullname="Kent Watsen">
            <organization>Juniper Networks</organization>
            <address>
                <email>kwatsen@juniper.net</email>
            </address>
        </author>
        <author initials="J.S." surname="Schoenwaelder" fullname="Juergen Schoenwaelder">
            <organization>Jacobs University Bremen</organization>
            <address>
                <email>j.schoenwaelder@jacobs-university.de</email>
            </address>
        </author>
 
        <date day="26" month="October" year="2014"/>
        <area>Operations</area>
        <workgroup>NETCONF Working Group</workgroup>
        <keyword>netconf-server</keyword>
        <abstract>
            <t>This draft defines a NETCONF server configuration data model.
            This data model enables configuration of the NETCONF service
            itself, including which transports it supports, what ports
            they listen on, whether call-home is supported, and associated
            parameters.</t>
        </abstract>
    </front>
    <middle>

        <section title="Introduction">
            <t>This draft defines a NETCONF <xref target="RFC6241"/> server
            configuration data model.
            This data model enables configuration of the NETCONF service
            itself, including which transports are supported, what ports
            the server listens on, whether call-home is supported, and
            associated parameters.</t>
            <section title="Terminology">
              <t>The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL",
              "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
              and "OPTIONAL" in this document are to be interpreted as
              described in RFC 2119 <xref target="RFC2119"/>.</t>
            </section>
            <section title="Tree Diagrams">
            <t>A simplified graphical representation of data models
            is used in this document.  The meaning of the symbols in
            these diagrams is as follows:
              <list style="symbols">
                <t>Brackets "[" and "]" enclose list keys.</t>
                <t>Abbreviations before data node names: "rw" means
                configuration (read-write) and "ro" state data 
                (read-only).</t>
                <t>Symbols after data node names: "?" means an optional
                node, "!" means a presence container, and "*" denotes a
                list and leaf-list.</t>
                <t>Parentheses enclose choice and case nodes, and case
                nodes are also marked with a colon (":").</t>
              </list>
            </t>
            </section>
        </section>

        <section title="Objectives">
          <t>The primary purpose of the YANG module defined herein is
          to enable the configuration of the NETCONF server 
          service on the device.  This scope includes the following 
          objectives:</t>
          <section title="Support all NETCONF transports">
            <t>The YANG module should support all current NETCONF
            transports, namely NETCONF over SSH <xref
            target="RFC6242"/> and NETCONF over TLS <xref
            target="rfc5539bis"/>, and be extensible
            to support future transports as necessary.</t>
            <t>Because implementations may not support all transports,
            the module should use YANG &quot;feature&quot; statements
            so that implementations can accurately advertise which
            transports are supported.</t>
          </section>
          <section title="Enable each transport to select which keys to use">
            <t>Systems may have a multiplicity of host-keys or server-certificates
               from which subsets are configured for specific uses.  For instance,
               a system may want to use one set of SSH host-keys when listening
               on port 830, and a different set of SSH host-keys when calling
               home.</t>
          </section>
          <section title="Support authenticating client-certificates">
            <t>When certificates are used to authenticate NETCONF clients, there is a need to 
               configure the system to know how to authenticate the certificates.  The system 
               should be able to do this either by using path-validation to a configured trust 
               anchor or by matching the client-certificate to one previously configured.</t>
          </section>
          <section title="Support mapping authenticated client-certificates to usernames">
            <t>Some transports (e.g., TLS) need additional support to map authenticated
               transport-level sessions to a NETCONF username.  The NETCONF server model
               defined herein should define an ability for this mapping to be configured."</t>
          </section>
          <section title="Support both Listening for connections and Call Home">
            <t>NETCONF has always supported the server opening
            a port to listen for client connections.  More recently
            the NETCONF working group defined support for call-home 
            (<xref target="draft-ietf-netconf-call-home"/>).  The
            module should configure both listening for connections
            and call-home.</t>
            <t>Because implementations may not support both listening for
            connections and call home, YANG &quot;feature&quot; statements
            should be used so that implementation can accurately 
            advertise the connection types it supports.</t>
          </section>
          <section title="For Call Home connections">
            <t>The following objectives only pertain to call home
             connections.</t>
            <section title="Support more than one application">
              <t>A device may be managed by more than one northbound
              application.  For instance, a deployment may have one
              application for provisioning and another for fault
              monitoring.  Therefore, when it is desired for a device
              to initiate call home connections, it should be able to
              do so for more than one application.</t>
            </section>
            <section title="Support applications having more than one server">
              <t>An application managing a device may implement a 
              high-availability strategy employing a multiplicity of
              active and/or passive servers.  Therefore, when it is
              desired for a device to initiate call home connections,
              it should be able to connect to any of the application's
              servers.</t>
            </section>
            <section title="Support a reconnection strategy">
              <t>Assuming an application has more than one server, then
              it becomes necessary to configure how a device should
              reconnect to the application should it lose its 
              connection to the application's servers.
              Of primary interest is if the device should
              start with first server defined in a user-ordered
              list of servers or with the last server it was connected
              to.  Secondary settings might specify the frequency of
              attempts and number of attempts per server.  Therefore,
              a reconnection strategy should be configurable.</t>
            </section>
            <section title="Support both persistent and periodic connections">
              <t>Applications may vary greatly on how frequently they
              need to interact with a device, how responsive interactions
              with devices need to be, and how many simultaneous connections
              they can support.  Some applications may need a persistent
              connection to devices to optimize real-time interactions, 
              while others are satisfied with periodic interactions and
              reduced resources required.  Therefore, when it is necessary
              for devices to initiate connections, the type of connection
              desired should be configured.</t>
            </section>
            <section title="Reconnection strategy for periodic connections">
              <t>The reconnection strategy should apply to both 
              persistent and periodic connections.  How it
              applies to periodic connections becomes clear when
              considering that a periodic &quot;connection&quot; is
              a logical connection to a single server.  That is,
              the periods of unconnectedness are intentional as 
              opposed to due to external reasons.  A periodic
              &quot;connection&quot; should always reconnect to 
              the same server until it is no longer able to, at 
              which time the reconnection strategy guides how to
              connect to another server.</t>
            </section>
            <section anchor="keepalives" title="Keep-alives for persistent connections">
              <t>If a persistent connection is desired, it is the 
              responsibility of the connection-initiator to actively
              test the "aliveness" of the connection.  The connection
              initiator must immediately work to reestablish a 
              persistent connection as soon as the connection is
              lost.  How often the connection should be tested is
              driven by application requirements, and therefore
              keep-alive settings should be configurable on a 
              per-application basis.</t>
            </section>
            <section title="Customizations for periodic connections">
              <t>If a periodic connection is desired, it is necessary
              for the device to know how often it should connect.  This
              delay essentially determines how long the 
              application might have to wait to send data to the device.
              This setting does not constrain how often the 
              device must wait to send data to the application, as the
              device should immediately connect to the application 
              whenever it has data to send to it.</t>
              <t>A common communication pattern is that one data
              transmission is many times closely followed by
              another.  For instance, if the device needs to send a
              notification message, there's a high probability that
              it will send another shortly thereafter.  Likewise,
              the application may have a sequence of pending messages
              to send.  Thus, it should be possible for a device to
              hold a connection open until some amount of time of no
              data being transmitted as transpired.</t>
            </section>
          </section>
        </section>

        <section title="Data Model">
          <section title="Overview">
            <section title="The &quot;session-options&quot; subtree">
              <t>
                <figure>
                  <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/session-options-tree.txt)
]]></artwork>
                </figure>
              </t>
              <t>The above subtree illustrates how this YANG module
              enables configuration of NETCONF session options,
              independent of any transport or connection strategy.
              Please see the YANG module (<xref target="yang-module"/>)
              for a complete description of these configuration knobs.</t>
            </section>
            <section title="The &quot;listen&quot; subtree">
              <t>
                <figure>
                  <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/listen-tree.txt)
]]></artwork>
                </figure>
              </t>
              <t>The above subtree illustrates how this YANG module
              enables configuration for listening for remote connections,
              as described in <xref target="RFC6242"/> and <xref
              target="rfc5539bis"/>.  Feature statements are used to limit both
              if listening is supported at all as well as for which transports.
              If listening for connections is supported, then the model 
              enables configuring a list of listening endpoints, each 
              configured with a
              user-specified name (the key field), the transport to use 
              (i.e. SSH, TLS), and the IP address and port to listen on.
              The port field is optional, defaulting to the transport-specific
              port when not configured.</t>
            </section>
            <section title="The &quot;call-home&quot; subtree">
              <t>
                <figure>
                  <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/call-home-tree.txt)
]]></artwork>
                </figure>
              </t>
              <t>The above subtree illustrates how this YANG module
              enables configuration for call home, as described in 
              <xref target="draft-ietf-netconf-call-home"/>.  Feature 
              statements are used to limit both if call-home is supported
              at all as well as for which transports, if it is.  If call-home
              is supported, then the model supports configuring a list of
              applications to connect to.  Each application is configured
              with a user-specified name (the key field), the transport to
              be used (i.e. SSH, TLS), and a list of remote endpoints, each
              having a name, an IP address, and an optional port.  Additionally,
              the configuration for each remote application indicates the
              connection-type (persistent vs. periodic) and associated 
              parameters, as well as the reconnection strategy to use.</t>

            </section>
            <section title="The &quot;ssh&quot; subtree">
              <t>
                <figure>
                  <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ssh-tree.txt)
]]></artwork>
                </figure>
              </t>
              <t>The above subtree illustrates how this YANG module
              provides SSH state independent of if the NETCONF server if 
              listening or calling home.  This data-model provides a 
              read-only listing of currently configured TLC certificates.</t>
            </section>


            <section title="The &quot;tls&quot; subtree">
              <t>
                <figure>
                  <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/tls-tree.txt)
]]></artwork>
                </figure>
              </t>
              <t>The above subtree illustrates how this YANG module
              provides TLS state and enables TLS configuration independent
              of if the NETCONF server if listening or calling home.
              This data-model provides 1) a read-only listing of currently
              configured TLC certificates and 2) an ability to configure
              how client-certificates are authenicated and how authenticated
              client-certificates are mapped to NETCONF user names.</t>

            </section>
          </section>


          <section title="YANG Module" anchor="yang-module">
            <t>This YANG module imports YANG types from <xref
            target="RFC6991"/>, and
            <xref target="draft-ietf-netmod-snmp-cfg"/>.</t>
            <t>
            <figure>
              <!--<preamble>The YANG Module</preamble>-->
              <artwork><![CDATA[
RFC Ed.: update the date below with the date of RFC publication 
and remove this note.

<CODE BEGINS> file "ietf-netconf-server@YYYY-MM-DD.yang"

INSERT_TEXT_FROM_FILE(ietf-netconf-server.yang)

<CODE ENDS>
]]></artwork>
            </figure>
            </t>
          </section>
        </section>

        <section title="Implementation strategy for keep-alives">
          <t>One of the objectives listed above, <xref target="keepalives">
          Keep-alives for persistent connections</xref>, indicates a need
          for a "keep-alive" mechanism.  This section specifies how the
          NETCONF keep-alive mechanism is to be implemented for both the
          SSH and TLS transports.</t>

          <t>Both SSH and TLS have the ability to support keep-alives securely.
          Using the strategies listed below, the keep-alive messages are sent
          inside the encrypted transport sessions.</t>

          <section title="Keep-alives for SSH">
            <t>The SSH keep-alive solution that is expected to be used
            is ubiquitous in practice, though never being explicitly defined
            in an RFC.  The strategy used is to purposely send a malformed
            request message with a flag set to ensure a response.  More
            specifically, per section 4 of <xref target="RFC4253"/>, either 
            SSH peer can send a SSH_MSG_GLOBAL_REQUEST message with "want 
            reply" set to '1' and that, if there is an error, will get back
            a SSH_MSG_REQUEST_FAILURE response.  Similarly, section 5 of 
            <xref target="RFC4253"/> says that either SSH peer can send a
            SSH_MSG_CHANNEL_REQUEST message with "want reply" set to '1' 
            and that, if there is an error, will get back a 
            SSH_MSG_CHANNEL_FAILURE response.</t>

            <t>To ensure that the request will fail, current implementations
            of this keep-alive strategy (e.g. OpenSSH's `sshd` server) send an
            invalid "request name" or "request type", respectively.  Abiding 
            to the extensibility guidelines specified in Section 6
            of <xref target="RFC4251"/>, these implementations use the 
            "name@domain".  For instance, when configured to send keep-alives,
            OpenSSH sends the string "keepalive@openssh.com".  In order to
            remain compatible with existing implementations, this draft does
            not require a specific "request name" or "request type" string
            be used, implementations are free to pick values of their choosing.</t>
          </section>

          <section title="Keep-alives for TLS">
            <t>The TLS keep-alive solution that is expected to be used is
            defined in <xref target="RFC6520"/>.  
            This solution allows both peers to advertise if they can
            receive heartbeat request messages from its peer.  
            For standard NETCONF over TLS connections, devices SHOULD
            advertise "peer_allowed_to_send", as per <xref target="RFC6520"/>.
            This advertisement is not a "MUST" in order to grandfather
            existing NETCONF over TLS implementations.
            For NETCONF Call Home, the network management
            system MUST advertise "peer_allowed_to_send" per
            <xref target="RFC6520"/>.  This is a "MUST" so as to ensure
            devices can depend in it always being there for call home
            connections, which is when keep-alives are needed the most.</t>
          </section>

        </section>

        <section title="Security Considerations">
            <t>The YANG modules defined in this memo are designed to be
            accessed via the NETCONF protocol <xref target="RFC6241"/>.  
            Authorization for access to specific portions of conceptual
            data and operations within this module is provided by the
            NETCONF access control model (NACM) <xref target="RFC6536"/>.</t>

            <t>There are a number of data nodes defined in the 
            "ietf-netconf-server" YANG module which are readable and/or 
            writable that may be considered sensitive or vulnerable in some 
            network environments.  Write and read operations to
            these data nodes can have a negative effect on network
            operations.  It is thus important to control write
            and read access to these data nodes.  Below are the 
            data nodes and their sensitivity/vulnerability.</t>

            <t>netconf-server/tls/client-auth/trusted-ca-certs:
            <list style="symbols">
              <t>This container contains certificates that the system
              is to use as trust anchors for authenticating TLS-specific
              client certificates.  Write access to this node should be
              protected.</t>
            </list>
            </t>

            <t>netconf-server/tls/client-auth/trusted-client-certs:
            <list style="symbols">
              <t>This container contains certificates that the system
              is to trust directly when authenticating TLS-specific
              client certificates.  Write access to this node should be
              protected.</t>
            </list>
            </t>

            <t>netconf-server/tls/client-auth/cert-map:
            <list style="symbols">
              <t>This container contains a user name that some deployments
              may consider sensitive information.  Read access to this 
              node may need to  be guarded.</t>
            </list>
            </t>
        </section>

        <section title="IANA Considerations">
          <t>This document registers  URI in the IETF XML 
          registry <xref target="RFC2119"/>.  Following the format in 
          <xref target="RFC3688"/>, the following registration is
          requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
      URI: urn:ietf:params:xml:ns:yang:ietf-netconf-server
      Registrant Contact: The NETCONF WG of the IETF.
      XML: N/A, the requested URI is an XML namespace.
]]></artwork>
            </figure>
          </t>
          <t>This document registers one YANG module in the
          YANG Module Names registry <xref target="RFC6020"/>.</t>
          <t>
            <figure>
                <artwork><![CDATA[
   name:         ietf-netconf-server
   namespace:    urn:ietf:params:xml:ns:yang:ietf-netconf-server
   prefix:       ncserver
   reference:    RFC XXXX
]]></artwork>
            </figure>
          </t>
        </section>

        <section title="Other Considerations">
            <t>The YANG module define herein does not itself support
            virtual routing and forwarding (VRF).  It is expected that
            external modules will augment in VRF designations when needed.</t>
        </section>

        <section title="Acknowledgements">
          <t>The authors would like to thank for following for
          lively discussions on list and in the halls (ordered
          by last name): Andy Bierman, Martin Bjorklund, 
          Benoit Claise, David Lamparter, Alan Luchuk, Ladislav Lhotka,
          Radek Krejci, Tom Petch, and Phil Shafer.</t>
         <t>
           Juergen Schoenwaelder and was partly funded by Flamingo, a
           Network of Excellence project (ICT-318488) supported by the
           European Commission under its Seventh Framework Programme.
         </t>
       </section>

    </middle>

    <back>
      <references title="Normative References">
          &rfc2119;
          &rfc4251;
          &rfc4253;
          &rfc6020;
          &rfc6241;
          &rfc6242;
          &rfc6520;
          &rfc6536;
          &rfc6991;
        <reference anchor='rfc5539bis'>
          <front>
            <title>
              Using the NETCONF Protocol over Transport Layer
              Security (TLS)
            </title>
            <author initials='M' surname='Badra' 
               fullname='Mohamad Badra'>
              <organization>LIMOS Laboratory</organization>
            </author>
            <author initials='A' surname='Luchuk'
               fullname='Alan Luchuk'>
              <organization>SNMP Research, Inc.</organization>
            </author>
            <author initials='J' surname='Schönwälder'
               fullname='Jürgen Schönwälder'>
              <organization>Jacobs University</organization>
            </author>
            <date month='October' day='21' year='2013' />
          </front>
          <seriesInfo name='Internet-Draft'
                 value='draft-ietf-netconf-rfc5539bis-04' />
        </reference>
       <reference anchor='draft-ietf-netmod-snmp-cfg'>
         <front>
           <title>A YANG Data Model for SNMP Configuration</title>
           <author initials='M' surname='Bjorklund' 
              fullname='Martin Bjorklund'>
             <organization>Tail-f Systems</organization>
           </author>
           <author initials='J' surname='Schönwälder'
              fullname='Jürgen Schönwälder'>
             <organization>Jacobs University</organization>
           </author>
           <date month='September' day='18' year='2014' />
         </front>
         <seriesInfo name='Internet-Draft' value='draft-ietf-netmod-snmp-cfg-08' />
       </reference>
       <reference anchor='draft-ietf-netconf-call-home'>
         <front>
           <title>
             NETCONF Call Home
           </title>
           <author initials='K.W.' surname='Watsen'
              fullname='Kent Watsen'>
             <organization>Juniper Networks</organization>
           </author>
           <date year='2014' />
         </front>
         <seriesInfo name='Internet-Draft'
                value='draft-ieft-netconf-call-home-00' />
       </reference>
<!--
       <reference anchor='draft-ietf-netmod-system-mgmt'>
         <front>
           <title>
             A YANG Data Model for System Management
           </title>
           <author initials='A.B.' surname='Bierman'
              fullname='Andy Bierman'>
             <organization>YumaWorks</organization>
           </author>
           <date month='May' day='14' year='2014' />
         </front>
         <seriesInfo name='Internet-Draft'
                value='draft-ieft-netmod-system-mgmt-16' />
      </reference>
-->
      </references>
      <references title="Informative References">

        <reference anchor="RFC3688">
          <front>
            <title>The IETF XML Registry</title>
            <author initials="M.M." surname="Mealling"
                    fullname="Michael Mealling">
              <organization>VeriSign Inc.</organization>
            </author>
            <date month="January" year="2004" />
          </front>
          <seriesInfo name="BCP" value="81" />
          <seriesInfo name="RFC" value="3688"/>
        </reference>
      </references>
      
      <section title="Examples">
        <section title="SSH Transport Configuration + State">
          <t>
            The following example illustrastes the &lt;get&gt; response from a NETCONF server
            that only supports SSH, both listening for incoming connections as well as 
            calling home to a single application having two endpoints.  Please also note
            that the list of host-keys at the end is read-only operational state.
          </t>
          <t>
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-ssh.xml)
]]></artwork>
            </figure>
          </t>
        </section>
  
        <section title="TLS Transport Configuration + State">
          <t>
            The following example illustrastes the &lt;get&gt; response from a NETCONF server
            that only supports TLS, both listening for incoming connections as well as 
            calling home to a single application having two endpoints.  Please note also
            the configurations for authenticating client certificates and mappings
            authenticated certificates to NETCONF user names.
          </t>
          <t>
            <figure>
              <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-tls.xml)
]]></artwork>
            </figure>
          </t>
        </section>
  
      </section>

      <section title="Change Log">
        <section title="00 to 01">
          <t>
            <list style="symbols">
              <t>Restructured document so it flows better</t>
              <t>Added trusted-ca-certs and trusted-client-certs
                 objects into the ietf-system-tls-auth module</t>
            </list>
          </t>
        </section>
        <section title="01 to 02">
          <t>
            <list style="symbols">
              <t>removed the "one-to-many" construct</t>
              <t>removed "address" as a key field</t>
              <t>removed "network-manager" terminology</t>
              <t>moved open issues to github issues</t>
              <t>brought TLS client auth back into model</t>
            </list>
          </t>
        </section>
        <section title="02 to 03">
          <t>
            <list style="symbols">
              <t>fixed tree diagrams and surrounding text</t>
            </list>
          </t>
        </section>
        <section title="03 to 04">
          <t>
            <list style="symbols">
              <t>reduced the number of grouping statements</t>
              <t>removed psk-maps and associated feature statements</t>
              <t>added ability for listen/call-home instances to specify
                 which host-keys/certificates (of all listed) to use</t>
              <t>clarified that last-connected should span reboots</t>
              <t>added missing "objectives" for selecting which keys to use,
                 authenticating client-certificates, and mapping authenticated
                 client-certificates to usernames</t>
              <t>clarified indirect client certificate authentication</t>
              <t>added keep-alive configuration for listen connections</t>
              <t>added global-level NETCONF session parameters</t>
            </list>
          </t>
        </section>
        <section title="04 to 05">
          <t>
            <list style="symbols">
              <t>Removed all refs to the old ietf-system-tls-auth module.</t>
            </list>
          </t>
        </section>
      </section>
      <section title="Open Issues">
        <t>Please see: https://github.com/netconf-wg/server-model/issues.</t>
      </section>
    </back>
</rfc>

